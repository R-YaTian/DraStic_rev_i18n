/*
   Copyright (C) 2011/2017 Hyllian/Jararaca - sergiogdb@gmail.com

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License
   as published by the Free Software Foundation; either version 2
   of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
   
   ------------------by Try791023 to Drastic-------NDS模擬器吧-----------------
*/

<vertex>
attribute vec2 a_vertex_coordinate;
attribute vec2 a_texture_coordinate;
	
uniform vec4 u_texture_size;
varying vec2 v_texture_coordinate;
varying vec4 v_texture_coordinate_1;
varying vec4 v_texture_coordinate_2;
varying vec4 v_texture_coordinate_3;
varying vec4 v_texture_coordinate_4;
varying vec4 v_texture_coordinate_5;
varying vec4 v_texture_coordinate_6;
varying vec4 v_texture_coordinate_7;
void main()
{
	vec2 ps = vec2(1.0 / u_texture_size.z, 1.0 / u_texture_size.w);
	float dx = ps.x;
	float dy = ps.y;
	gl_Position = vec4(a_vertex_coordinate.xy, 0.0, 1.0);
	v_texture_coordinate = a_texture_coordinate.xy;
      //     A1 B1 C1
      //  A0  A  B  C C4
      //  D0  D  E  F F4
      //  G0  G  H  I I4
      //     G5 H5 I5
	v_texture_coordinate_1 = a_texture_coordinate.xxxy + vec4( -dx, 0, dx,-2.0*dy); // A1 B1 C1
	v_texture_coordinate_2 = a_texture_coordinate.xxxy + vec4( -dx, 0, dx,    -dy); //  A  B  C
	v_texture_coordinate_3 = a_texture_coordinate.xxxy + vec4( -dx, 0, dx,    0.0); //  D  E  F
	v_texture_coordinate_4 = a_texture_coordinate.xxxy + vec4( -dx, 0, dx,     dy); //  G  H  I
	v_texture_coordinate_5 = a_texture_coordinate.xxxy + vec4( -dx, 0, dx, 2.0*dy); // G5 H5 I5
	v_texture_coordinate_6 = a_texture_coordinate.xyyy + vec4(-2.0*dx,-dy, 0.0,dy); // A0 D0 G0
	v_texture_coordinate_7 = a_texture_coordinate.xyyy + vec4( 2.0*dx,-dy, 0.0,dy); // C4 F4 I4
}
</vertex>
<fragment>

uniform sampler2D u_texture;
uniform vec4 u_texture_size;
varying vec2 v_texture_coordinate;
varying vec4 v_texture_coordinate_1;
varying vec4 v_texture_coordinate_2;
varying vec4 v_texture_coordinate_3;
varying vec4 v_texture_coordinate_4;
varying vec4 v_texture_coordinate_5;
varying vec4 v_texture_coordinate_6;
varying vec4 v_texture_coordinate_7;

const float coef = 2.0;
const float y_weight = 48.0;
const float u_weight = 7.0;
const float v_weight = 6.0;
const mat3 yuv = mat3(0.299, 0.587, 0.114, -0.169, -0.331, 0.499, 0.499, -0.418, -0.0813);
const mat3 yuv_weighted = mat3(y_weight * yuv[0], u_weight * yuv[1], v_weight * yuv[2]);

    vec4 RGBtoYUV(vec3 v0, vec3 v1, vec3 v2, vec3 v3) {
      float a = yuv_weighted[0].x * v0.x + yuv_weighted[0].y * v0.y + yuv_weighted[0].z * v0.z;
      float b = yuv_weighted[0].x * v1.x + yuv_weighted[0].y * v1.y + yuv_weighted[0].z * v1.z;
      float c = yuv_weighted[0].x * v2.x + yuv_weighted[0].y * v2.y + yuv_weighted[0].z * v2.z;
      float d = yuv_weighted[0].x * v3.x + yuv_weighted[0].y * v3.y + yuv_weighted[0].z * v3.z;

      return vec4(a, b, c, d);
    }

    bvec4 _and_(bvec4 A, bvec4 B) {
      return bvec4(A.x && B.x, A.y && B.y, A.z && B.z, A.w && B.w);
    }

    bvec4 _or_(bvec4 A, bvec4 B) {
      return bvec4(A.x || B.x, A.y || B.y, A.z || B.z, A.w || B.w);
    } 

    vec4 df(vec4 A, vec4 B) {
      return vec4(abs(A - B));
    }
	
	bvec4 close(vec4 A, vec4 B) {
      return (lessThan(df(A, B), vec4(15.0)));
    }

    vec4 weighted_distance(vec4 a, vec4 b, vec4 c, vec4 d, vec4 e, vec4 f, vec4 g, vec4 h) {
      return (df(a, b) + df(a, c) + df(d, e) + df(d, f) + 4.0 * df(g, h));
    }


    void main() {
	vec2 fp = fract(v_texture_coordinate.xy * u_texture_size.zw);

	vec3 A1 = texture2D(u_texture, v_texture_coordinate_1.xw).rgb;
	vec3 B1 = texture2D(u_texture, v_texture_coordinate_1.yw).rgb;
	vec3 C1 = texture2D(u_texture, v_texture_coordinate_1.zw).rgb;

	vec3 A  = texture2D(u_texture, v_texture_coordinate_2.xw).rgb;
	vec3 B  = texture2D(u_texture, v_texture_coordinate_2.yw).rgb;
	vec3 C  = texture2D(u_texture, v_texture_coordinate_2.zw).rgb;

	vec3 D  = texture2D(u_texture, v_texture_coordinate_3.xw).rgb;
	vec3 E  = texture2D(u_texture, v_texture_coordinate_3.yw).rgb;
	vec3 F  = texture2D(u_texture, v_texture_coordinate_3.zw).rgb;

	vec3 G  = texture2D(u_texture, v_texture_coordinate_4.xw).rgb;
	vec3 H  = texture2D(u_texture, v_texture_coordinate_4.yw).rgb;
	vec3 I  = texture2D(u_texture, v_texture_coordinate_4.zw).rgb;

	vec3 G5 = texture2D(u_texture, v_texture_coordinate_5.xw).rgb;
	vec3 H5 = texture2D(u_texture, v_texture_coordinate_5.yw).rgb;
	vec3 I5 = texture2D(u_texture, v_texture_coordinate_5.zw).rgb;

	vec3 A0 = texture2D(u_texture, v_texture_coordinate_6.xy).rgb;
	vec3 D0 = texture2D(u_texture, v_texture_coordinate_6.xz).rgb;
	vec3 G0 = texture2D(u_texture, v_texture_coordinate_6.xw).rgb;

	vec3 C4 = texture2D(u_texture, v_texture_coordinate_7.xy).rgb;
	vec3 F4 = texture2D(u_texture, v_texture_coordinate_7.xz).rgb;
	vec3 I4 = texture2D(u_texture, v_texture_coordinate_7.xw).rgb;

	vec4 b = RGBtoYUV(B, D, H, F);
	vec4 c = RGBtoYUV(C, A, G, I);
	vec4 e = RGBtoYUV(E, E, E, E);
	vec4 d = b.yzwx;
	vec4 f = b.wxyz;
	vec4 g = c.zwxy;
	vec4 h = b.zwxy;
	vec4 i = c.wxyz;

	vec4 i4 = RGBtoYUV(I4, C1, A0, G5);
	vec4 i5 = RGBtoYUV(I5, C4, A1, G0);
	vec4 h5 = RGBtoYUV(H5, F4, B1, D0);
	vec4 f4 = h5.yzwx;

	bvec4 t1 = _and_( notEqual(e, f), notEqual(e, h) );
	bvec4 t2 = _and_( not(close(f, b)), not(close(f, c)) );
	bvec4 t3 = _and_( not(close(h, d)), not(close(h, g)) );
	bvec4 t4 = _and_( not(close(f, f4)), not(close(f, i4)) );
	bvec4 t5 = _and_( not(close(h, h5)), not(close(h, i5)) );
	bvec4 t6 = _and_( close(e, i), _or_(t4, t5) );
	bvec4 t7 = _or_( close(e, g), close(e, c) );
	bvec4 interp_restriction_lv1 = _and_( t1, _or_( _or_( _or_(t2, t3), t6 ), t7 ) );
    bvec4 interp_restriction_lv2_left = _and_( notEqual(e, g), notEqual(d, g) );
    bvec4 interp_restriction_lv2_up   = _and_( notEqual(e, c), notEqual(b, c) );

    bvec4 edr      = _and_( lessThan(weighted_distance(e, c, g, i, h5, f4, h, f), 
                                       weighted_distance(h, d, i5, f, i4, b, e, i)), interp_restriction_lv1 );
    bvec4 edr_left = _and_( lessThanEqual(coef * df(f, g), df(h, c)), interp_restriction_lv2_left );
    bvec4 edr_up   = _and_( greaterThanEqual(df(f, g), coef * df(h, c)), interp_restriction_lv2_up );

	bvec4 px = lessThanEqual(df(e, f), df(e, h));

	vec3 P[4];
	P[0] = px.x ? F : H;
	P[1] = px.y ? B : F;
	P[2] = px.z ? D : B;
	P[3] = px.w ? H : D;

	vec3 res = E;

	if (fp.x >=0.5)
	{
	   if (fp.y >=0.5)
	   {
		if (edr.x && edr_left.x && edr_up.x)
		{
			res  = mix(E , P[0],  0.833333);
		}
		else if (edr.x && (edr_left.x || edr_up.x))
		{
			res  = mix(E , P[0],  0.75);
		}
		else if (edr.y && edr_left.y && edr.w && edr_up.w)
		{
			res  = mix(E , P[1],  0.25);
			res  = mix(E , P[3],  0.25);
		}
		else if (edr.y && edr_left.y)
		{
			res  = mix(E , P[1],  0.25);
		}
		else if (edr.w && edr_up.w)
		{
			res  = mix(E , P[3],  0.25);
		}
		else if (edr.x)
		{
			res  = mix(E , P[0],  0.5);
		}
	   }
	   else
	   {
		if (edr.y && edr_left.y && edr_up.y)
		{
			res  = mix(E , P[1],  0.833333);
		}
		else if (edr.y && (edr_left.y || edr_up.y))
		{
			res  = mix(E , P[1],  0.75);
		}
		else if (edr.z && edr_left.z && edr.x && edr_up.x)
		{
			res  = mix(E , P[2],  0.25);
			res  = mix(E , P[0],  0.25);
		}
		else if (edr.z && edr_left.z)
		{
			res  = mix(E , P[2],  0.25);
		}
		else if (edr.x && edr_up.x)
		{
			res  = mix(E , P[0],  0.25);
		}
		else if (edr.y)
		{
			res  = mix(E , P[1],  0.5);
		}
	   }
	}
	else
	{
	   if (fp.y >=0.5)
	   {
		if (edr.w && edr_left.w && edr_up.w)
		{
			res  = mix(E , P[3],  0.833333);
		}
		else if (edr.w && (edr_left.w || edr_up.w))
		{
			res  = mix(E , P[3],  0.75);
		}
		else if (edr.x && edr_left.x && edr.z && edr_up.z)
		{
			res  = mix(E , P[0],  0.25);
			res  = mix(E , P[2],  0.25);
		}
		else if (edr.x && edr_left.x)
		{
			res  = mix(E , P[0],  0.25);
		}
		else if (edr.z && edr_up.z)
		{
			res  = mix(E , P[2],  0.25);
		}
		else if (edr.w)
		{
			res  = mix(E , P[3],  0.5);
		}
	   }
	   else
	   {
		if (edr.z && edr_left.z && edr_up.z)
		{
			res  = mix(E , P[2],  0.833333);
		}
		else if (edr.z && (edr_left.z || edr_up.z))
		{
			res  = mix(E , P[2],  0.75);
		}
		else if (edr.w && edr_left.w && edr.y && edr_up.y)
		{
			res  = mix(E , P[3],  0.25);
			res  = mix(E , P[1],  0.25);
		}
		else if (edr.w && edr_left.w)
		{
			res  = mix(E , P[3],  0.25);
		}
		else if (edr.y && edr_up.y)
		{
			res  = mix(E , P[1],  0.25);
		}
		else if (edr.z)
		{
			res  = mix(E , P[2],  0.5);
		}
	   }
	}
	
	gl_FragColor.rgb = res;
}
</fragment>