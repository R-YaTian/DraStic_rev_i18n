<vertex>
attribute vec2 a_vertex_coordinate;
attribute vec2 a_texture_coordinate;
uniform vec4 u_texture_size;

varying vec2 v_texture_coordinate;

void main()
{
  gl_Position = vec4(a_vertex_coordinate.xy, 0.0, 1.0);
  v_texture_coordinate = a_texture_coordinate;
  
}
</vertex>

<fragment>
#ifndef BRIGHTEN_SCANLINES
#define BRIGHTEN_SCANLINES 16.0
#endif
#ifndef BRIGHTEN_LCD
#define BRIGHTEN_LCD 4.0
#endif
#define r0 0.5 //red_0
#define g0 0.3 //green_0
#define b0 0.4 //blue_0
#define g1 0.1 //green_1
#define b1 0.2 //blue_1
#define r1 0.1 //red_1
#define b2 0.2 //blue_2
#define r2 0.3 //red_2
#define g2 0.2 //green_2
uniform sampler2D u_texture;
uniform vec4 u_texture_size;

varying vec2 v_texture_coordinate;

const float brighten_scanlines = BRIGHTEN_SCANLINES * 5.0;
const float brighten_lcd = BRIGHTEN_LCD * 5.0;
const vec3 offsets = 3.141592654 * vec3(1.0);

void main()
{
  vec2 omega = 3.141592654 * u_texture_size.zw;
  vec3 res = texture2D(u_texture, v_texture_coordinate).rgb * 1.33;
  vec2 angle = v_texture_coordinate * omega;
  
  float yfactor = (brighten_scanlines + sin(angle.y)) / brighten_scanlines;
  vec3 xfactor = (brighten_lcd + sin(angle.x + offsets)) / brighten_lcd;

  vec3 colour = pow(texture2D(u_texture, v_texture_coordinate.xy).rgb, vec3(2.0));
	colour = clamp(colour * 1.0, 0.0, 1.0);
	colour = pow(
		mat3(r0,  g1, b1,
			  r1, g0,  b2,
			  r2, g2, b0) * colour,
		vec3(0.1)
	);

	colour.rgb = yfactor * xfactor * colour.rgb * res;
	
	gl_FragColor = vec4(colour.rgb, 1.0);
}
</fragment>