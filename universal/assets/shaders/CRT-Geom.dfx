// CRT-Geom shader
=============================================
<options>
name=CRT-Geom
textures=1
</options>

<fheader>
#if GL_ES
#ifdef GL_FRAGMENT_PRECISION_HIGH
precision highp float;
#else
precision mediump float;
#endif
#endif
</fheader>

<header>
// Parameters
#define CRTgamma 2.4 // "CRTGeom Target Gamma" 2.4 0.1 5.0 0.1
#define monitorgamma 2.2 // "CRTGeom Monitor Gamma" 2.2 0.1 5.0 0.1
#define d 1.5 // "CRTGeom Distance" 1.5 0.1 3.0 0.1
#define CURVATURE 1.0 // "CRTGeom Curvature Toggle" 1.0 0.0 1.0 1.0
#define R 2.0 // "CRTGeom Curvature Radius" 2.0 0.1 10.0 0.1
#define cornersize 0.03 // "CRTGeom Corner Size" 0.03 0.001 1.0 0.005
#define cornersmooth 1000.0 // "CRTGeom Corner Smoothness" 1000.0 80.0 2000.0 100.0
#define x_tilt 0.0 // "CRTGeom Horizontal Tilt" 0.0 -0.5 0.5 0.05
#define y_tilt 0.0 // "CRTGeom Vertical Tilt" 0.0 -0.5 0.5 0.05
#define overscan_x 100.0 // "CRTGeom Horiz. Overscan %" 100.0 -125.0 125.0 1.0
#define overscan_y 100.0 // "CRTGeom Vert. Overscan %" 100.0 -125.0 125.0 1.0
#define DOTMASK 0.3 // "CRTGeom Dot Mask Toggle" 0.3 0.0 0.3 0.3
#define SHARPER 1.0 // "CRTGeom Sharpness" 1.0 1.0 3.0 1.0
#define scanline_weight 0.3 // "CRTGeom Scanline Weight" 0.3 0.1 0.5 0.05

// Comment the next line to disable interpolation in linear gamma (and
// gain speed).
#define LINEAR_PROCESSING

// Enable 3x oversampling of the beam profile; improves moire effect caused by scanlines+curvature
#define OVERSAMPLE

// Use the older, purely gaussian beam profile; uncomment for speed
//#define USEGAUSSIAN

// Use interlacing detection; may interfere with other shaders if combined
#define INTERLACED

// Enable Dot-mask emulation:
// Output pixels are alternately tinted green and magenta.
//#define DOTMASK

// Macros.
#define FIX(c) max(abs(c), 1e-5);
#define PI 3.141592653589

#ifdef LINEAR_PROCESSING
#define TEX2D(c) pow(texture2D(u_texture, (c)), vec4(CRTgamma))
#else
#define TEX2D(c) texture2D(u_texture, (c))
#endif

// aspect ratio
const vec2 aspect = vec2(1.0, 0.75);

float intersect(vec2 xy, vec2 sinangle, vec2 cosangle) {
  float A = dot(xy,xy)+d*d;
  float B = 2.0*(R*(dot(xy,sinangle)-d*cosangle.x*cosangle.y)-d*d);
  float C = d*d + 2.0*R*d*cosangle.x*cosangle.y;
  return (-B-sqrt(B*B-4.0*A*C))/(2.0*A);
}

vec2 bkwtrans(vec2 xy, vec2 sinangle, vec2 cosangle) {
  float c = intersect(xy, sinangle, cosangle);
  vec2 point = vec2(c)*xy;
  point -= vec2(-R)*sinangle;
  point /= vec2(R);
  vec2 tang = sinangle/cosangle;
  vec2 poc = point/cosangle;
  float A = dot(tang,tang)+1.0;
  float B = -2.0*dot(poc,tang);
  float C = dot(poc,poc)-1.0;
  float a = (-B+sqrt(B*B-4.0*A*C))/(2.0*A);
  vec2 uv = (point-a*sinangle)/cosangle;
  float r = FIX(R*acos(a));
  return uv*r/sin(r/R);
}

vec2 fwtrans(vec2 uv, vec2 sinangle, vec2 cosangle) {
  float r = FIX(sqrt(dot(uv,uv)));
  uv *= sin(r/R)/r;
  float x = 1.0-cos(r/R);
  float D = d/R + x*cosangle.x*cosangle.y+dot(uv,sinangle);
  return d*(uv*cosangle-x*sinangle)/D;
}

vec3 maxscale(vec2 sinangle, vec2 cosangle) {
  vec2 c = bkwtrans(-R * sinangle / (1.0 + R/d*cosangle.x*cosangle.y), sinangle, cosangle);
  vec2 a = vec2(0.5,0.5)*aspect;
  vec2 lo = vec2(fwtrans(vec2(-a.x,c.y), sinangle, cosangle).x,
    fwtrans(vec2(c.x,-a.y), sinangle, cosangle).y)/aspect;
  vec2 hi = vec2(fwtrans(vec2(+a.x,c.y), sinangle, cosangle).x,
    fwtrans(vec2(c.x,+a.y), sinangle, cosangle).y)/aspect;
  return vec3((hi+lo)*aspect*0.5,max(hi.x-lo.x,hi.y-lo.y));
}

// Calculate the influence of a scanline on the current pixel.
//
// 'distance' is the distance in texture coordinates from the current
// pixel to the scanline in question.
// 'color' is the colour of the scanline at the horizontal location of
// the current pixel.
vec4 scanlineWeights(float distance, vec4 color) {
  // "wid" controls the width of the scanline beam, for each RGB
  // channel The "weights" lines basically specify the formula
  // that gives you the profile of the beam, i.e. the intensity as
  // a function of distance from the vertical center of the
  // scanline. In this case, it is gaussian if width=2, and
  // becomes nongaussian for larger widths. Ideally this should
  // be normalized so that the integral across the beam is
  // independent of its width. That is, for a narrower beam
  // "weights" should have a higher peak at the center of the
  // scanline than for a wider beam.
#ifdef USEGAUSSIAN
  vec4 wid = 0.3 + 0.1 * pow(color, vec4(3.0));
  vec4 weights = vec4(distance / wid);
  return 0.4 * exp(-weights * weights) / wid;
#else
  vec4 wid = 2.0 + 2.0 * pow(color, vec4(4.0));
  vec4 weights = vec4(distance / scanline_weight);
  return 1.4 * exp(-pow(weights * inversesqrt(0.5 * wid), wid)) / (0.6 + 0.2 * wid);
#endif
}
</header>

<texture:0>
input=framebuffer
min_filter=GL_NEAREST
mag_filter=GL_NEAREST
</texture>

<pass>
shader=crt-geom.dsd
sampler:u_texture=0
</pass>
